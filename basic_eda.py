# -*- coding: utf-8 -*-
"""Basic EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bOUlG0ZvU0Ix68q8tU6mGcBl_ZiP274l

### Data Dictionary

* order_id: Unique ID of the order
* customer_id: ID of the customer who ordered the food
* restaurant_name: Name of the restaurant
* cuisine_type: Cuisine ordered by the customer
* cost: Cost of the order
* day_of_the_week: Indicates whether the order is placed on a weekday or weekend (The weekday is from Monday to Friday and the weekend is Saturday and Sunday)
* rating: Rating given by the customer out of 5
* food_preparation_time: Time (in minutes) taken by the restaurant to prepare the food. This is calculated by taking the difference between the timestamps of the restaurant's order confirmation and the delivery person's pick-up confirmation.
* delivery_time: Time (in minutes) taken by the delivery person to deliver the food package. This is calculated by taking the difference between the timestamps of the delivery person's pick-up confirmation and drop-off information
"""

# import libraries for data manipulation
import numpy as np
import pandas as pd

# import libraries for data visualization
import matplotlib.pyplot as plt
import seaborn as sns

# To suppress warnings
import warnings
warnings.filterwarnings("ignore")

#mount google drive
from google.colab import drive
drive.mount('/content/drive')

# read the data
df = pd.read_csv('/content/drive/MyDrive/MIT Python Work/Week 2/Project/foodhub_order.csv')
# returns the first 5 rows
df.head()

# use .shape to show the shape of our data (rows, columns)
df.shape

# Use info() to print a concise summary of the DataFrame
df.info()

# use the is.null function to find any null value then .sum to add the quantities per each column
df.isnull().sum()

# provides a statstical summary of the data and transposes the table for easier analysis
df.describe().T

# Count the number of orders with a rating of 'Not given'
No_rating = df[df['rating'] == 'Not given']['rating'].count()

print(No_rating)

df.head()

#counts number of orders per customer
df['customer_id'].value_counts()

# Calculate order counts for each restaurant
restaurant_order_counts = df['restaurant_name'].value_counts()

# Get the top 5 restaurants
top_5_restaurants = restaurant_order_counts.head(5)

# Create the countplot
plt.figure(figsize=(10, 6))
sns.countplot(data = df,
              x='restaurant_name',
              order=top_5_restaurants.index)
plt.title('Top 5 Restaurants by Order Quantity')
plt.xlabel('Restaurant Name')
plt.ylabel('Order Count')
plt.xticks(rotation=45);  # Rotate x-axis labels for better readability

#box plot showing delivery time
plt.figure(figsize=(5, 5))
plt.title('Variation in Delivery Time')
plt.xlabel("Delivery Time In Minutes")
sns.boxplot(data=df, x='delivery_time');

#box plot showing food preperation time
plt.figure(figsize=(5, 5))
plt.title('Variation in Food Time Preperation')
plt.xlabel("Food Preparation Time In Minutes")
sns.boxplot(data=df, x='food_preparation_time');

#plot showing the counts of orders per cost
plt.figure(figsize=(5, 5))
plt.title('Count of Orders per Cost')
plt.xlabel("Price In USD")
sns.histplot(
    data=df,
    x='cost_of_the_order'
    );

# Count Plot that graphs the count of cuisine type per day of the week
plt.figure(figsize=(15, 5))
plt.title('Ordering Counts by Cuisine Type Per Day of Week')
sns.countplot(
    data=df,
    x="cuisine_type",
    hue= "day_of_the_week",
    order=df["cuisine_type"].value_counts().index
)
plt.xticks(rotation=30, ha = 'right')
plt.xlabel("");

# Calculate order counts for each restaurant
restaurant_order_counts = df['restaurant_name'].value_counts()

# Get the top 5 restaurants
top_5_restaurants = restaurant_order_counts.head(5)

print(top_5_restaurants)

# Calculate order counts for each cuisine type by day of week
pop_weekend_cuisine = df.groupby(['day_of_the_week'])['cuisine_type'].value_counts()

# Get the top 5 cuisines by weekend
top_5_cuisines_weekends = pop_weekend_cuisine.head(6)

print(top_5_cuisines_weekends)

# slices data frame to count all orders over 20
df_over20 = df[df['cost_of_the_order'] > 20]['cost_of_the_order'].count()

#slices dataframe to count all observations in the cost of the order column
df_total_orders = df['cost_of_the_order'].count()

#calculates the percent of orders over $20 out of all orders
percentage_over20 = (df_over20/df_total_orders)*100
print(percentage_over20)

# calculates mean order delivery time in minutes
df_mean = df['delivery_time'].mean()
print(df_mean)

# Calculates value counts by customer ID
customer_counts = df["customer_id"].value_counts()

#creates a dataframe with the top 3 observations
top3 = customer_counts.head(3)
print(top3)

"""Relationship Between Cuisine Type and Cost of Orders"""

plt.figure(figsize=(20,7))
sns.stripplot(data=df, x='cuisine_type', y='cost_of_the_order', jitter=True, alpha = .3);

"""Relationship Between Delivery Time and Day of the Week"""

sns.violinplot(data=df, y='day_of_the_week', x='delivery_time');

"""Relationship Between Rating and Delivery Time"""

plt.figure(figsize=(15, 7))
sns.pointplot(data = df, x = 'rating', y = 'delivery_time');

"""Relationship Between Cuisine Type and Delivery Time


"""

plt.figure(figsize=(15,7))
sns.boxplot(data = df, x = "cuisine_type", y = "delivery_time")
plt.xticks(rotation = 30);

"""Relationship Between Cuisine Type and Food Preparation Time"""

plt.figure(figsize=(15,7))
sns.boxplot(data = df, x = "cuisine_type", y = "food_preparation_time")
plt.xticks(rotation = 30);

col_list = ['cost_of_the_order', 'food_preparation_time', 'delivery_time']
plt.figure(figsize=(15, 7))
sns.heatmap(df[col_list].corr(), annot=True,cmap = 'Blues');

# Filter out rows where rating is 'Not given'
clean_rating = df['rating'] != 'Not given'
df = df[clean_rating]

# Convert rating column to integers
df['rating'] = df['rating'].astype(int)

# Filter restaurants with more than 50 ratings
rest_over50 = df.groupby('restaurant_name')['rating'].count()
rest_over50 = rest_over50[rest_over50 > 50]

# Filter restaurants with an average rating greater than 4
rest_over4 = df.groupby('restaurant_name')['rating'].mean()
rest_over4 = rest_over4[rest_over4 > 4]

# Find restaurants that meet both criteria
promotional_restaurants = list(set(rest_over4.index) & set(rest_over50.index))

print("The restaurants that meet the criteria are: ", [promotional_restaurants])

#function to apply a 25% charge on orders over $20 and a 15% charge on orders over $5
def compute_rev(x):
    if x > 20:
        return x*0.25
    elif x > 5:
        return x*0.15
    else:
        return x*0
# creates a revenue column which applys the % charge to the cost of the order column
df['Revenue'] = df['cost_of_the_order'].apply(compute_rev)
df.head()

#calculates total time with food prep time and delivery time
df['total_time'] = df['food_preparation_time'] + df['delivery_time']

#filters values that are over 60 minutes
df['over60'] = df['total_time'] > 60


#counts the true/false values where true equals orders over 60 minutes
df['over60'].value_counts()

#retuns the percent of orders that take more than 60 minutes to be delivered from time the order is placed
percent = (119/1043)*100
print(percent)

# calculates mean of weekday and weekend orders
mean_weekday = df[df['day_of_the_week'] == 'Weekday']['delivery_time'].mean()
mean_weekend = df[df['day_of_the_week'] == 'Weekend']['delivery_time'].mean()

print('Mean Delivery Time on Weekdays:', mean_weekday, "minutes")
print('Mean Delivery Time on Weekends:', mean_weekend, "minutes")

"""---"""